# .github/workflows/update-clones.yml
name: Update Clone Counter

on:
  schedule:
    - cron: '5 0 * * *'
  workflow_dispatch:

jobs:
  update-clones:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.CLONE_STATS_TOKEN }}
      GIST_ID:  fc9283f4379c4b0b6211de82d01e2cec
      BADGE_FILE:       "asn1plus_clones.json"
      METADATA_FILE:    "asn1plus_clones_meta.json"

    steps:
      - name: Fetch 14-day clone stats
        id: fetch
        run: |
          echo "ðŸ” Fetching 14-day clone statsâ€¦"
          resp=$(curl -s -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/traffic/clones?per=day")
          windowTotal=$(echo "$resp" | jq '.count // 0')
          latest=$(echo "$resp" | jq -r '.clones | sort_by(.timestamp) | last')
          latestTs=$(echo "$latest" | jq -r .timestamp)
          latestCount=$(echo "$latest" | jq -r .count)

          echo "windowTotal=$windowTotal"   >> $GITHUB_OUTPUT
          echo "latestTs=$latestTs"         >> $GITHUB_OUTPUT
          echo "latestCount=$latestCount"   >> $GITHUB_OUTPUT

      - name: Read & safely update Gist badge + metadata
        run: |
          set -e

          # Load Gist metadata
          gist_json=$(curl -s -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/gists/$GIST_ID")
          badge_url=$(echo "$gist_json" | jq -r ".files[\"$BADGE_FILE\"].raw_url // empty")
          meta_url=$(echo "$gist_json"  | jq -r ".files[\"$METADATA_FILE\"].raw_url // empty")

          if [ -z "$meta_url" ]; then
            echo "âŒ Metadata file '$METADATA_FILE' not found. Aborting to avoid reset."
            exit 1
          fi

          # Fetch existing files
          old_badge=$(curl -s "$badge_url")
          old_meta=$(curl -s "$meta_url")
          echo "$old_meta" > metadata.bak.json

          # Parse existing metadata
          oldLife=$(echo "$old_meta" | jq -r '.lifetime // "0"')
          prevTs=$(echo "$old_meta" | jq -r '.lastTimestamp // ""')

          # Compute diff: only add when timestamp changes
          if [ "$prevTs" = "${{ steps.fetch.outputs.latestTs }}" ]; then
            diff=0
          else
            diff=${{ steps.fetch.outputs.latestCount }}
          fi
          newLife=$(( oldLife + diff ))

          # Build new badge JSON (valid keys only)
          new_badge=$(jq -n \
            --arg m "$newLife" \
            '{ schemaVersion: 1, label: "clones", message: $m, color: "blue" }')

          # Build new metadata JSON
          new_meta=$(jq -n \
            --arg l "$newLife" \
            --arg t "${{ steps.fetch.outputs.latestTs }}" \
            '{ lifetime: $l, lastTimestamp: $t }')

          # Prepare patch payload
          filename_badge="$BADGE_FILE"
          filename_meta="$METADATA_FILE"
          payload=$(jq -n \
            --arg fb "$filename_badge" --arg bb "$new_badge" \
            --arg fm "$filename_meta" --arg mm "$new_meta" \
            '{
              files: {
                ($fb): { content: $bb },
                ($fm): { content: $mm }
              }
            }')

          # Patch the Gist
          curl -s -X PATCH \
            -H "Authorization: token $GH_TOKEN" \
            -d "$payload" \
            "https://api.github.com/gists/$GIST_ID" \
            >/dev/null
          echo "âœ… Gist updated: badge + metadata (backup in metadata.bak.json)"

      - name: Show Shields.io badge snippet
        run: |
          echo "Copy this into your README:"
          echo "![Clones](https://img.shields.io/badge/dynamic/json?url=https://gist.githubusercontent.com/${{ github.actor }}/${{ env.GIST_ID }}/raw/${{ env.BADGE_FILE }}&query=%24.message&label=clones)"

